################################################################################################################################################################################################################################################
################################################################################################################################################################################################################################################
################################################################################################################################################################################################################################################

1. "Devour" mechanic - added devour from hand, next is from market and then from top of deck/innercircle?
	- add devour from deck after you ask if you could perhaps use Deck.cs class since RNG mechanics will be reimplemented properly (see down a bit for a better explanation)

3. victory score class for end game trigger, unit tests for victory point scoring

4. card width/height are hardcoded? we need some file/class that will hold the dimensions for cards sizes in market display?
different for card sizes in hand, as well as different for the hover to display certain areas like inner circle which i plan to implement later...

5. there will be a card that says promote a card from the top of your library (the one you didnt draw yet obviously) so will i need a special new class for the deck called Deck.cs? in which i will handle the Deterministic RNG (Random Number Generation)
and similar things related to Deck? or will this be better somewhere else we already have a class? im not too sure since im new to game dev

6. adding ESC button menu to quit via button + adding proper end turn button, not just pressing ENTER

7. make sure that right click cannot exit market, just cancel actions?? do we want that?

8. revisit GameCOmmands - see if i can separate some other commands from the main file to other like promote command and stuff like that? is it viable?

9. i have some new testcases added by Gemini AI automatically inside the Antigravity IDE, the tests are called GameLogicTests.cs and the IntegrationTests.cs
	- i have kept the nomenclature to fit the their design counterparts, i only make up a new name if there really isnt any other option, otherwise i try to have unit tests dedicated for each class, if that goes under the industry standard

10. rename MatchController into MatchManager, rename WorldBuilder into WorldFactory, rename IUISystem into IUIManager to be inline

################################################################################################################################################################################################################################################
################################################################################################################################################################################################################################################
################################################################################################################################################################################################################################################

C# Senior suggestions

Code Specific Recommendations

I noticed a small potential bug in GameplayState.cs regarding UI event subscriptions:
C#

// In InitializeEventSubscriptions()
_uiManagerBacking.OnMarketToggleRequest -= HandleMarketToggle; // Good practice
_uiManagerBacking.OnMarketToggleRequest += HandleMarketToggle;

You are correctly unsubscribing before subscribing to avoid memory leaks/double-firing. However, relying on InitializeEventSubscriptions being called manually in tests vs LoadContent in the game can get messy.

    Advice: Ensure UnloadContent explicitly unsubscribes from these events to prevent zombie references if you ever restart the game state without restarting the app.



__________________________________________


The "Watch Out" Areas (based on the files provided):

    Presence Logic (MapManager):

        In Tyrants, "Presence" is tricky. You have presence if you have a piece there, OR if you have a piece adjacent.

        In ActionSystem.cs, you call _mapManager.HasPresence(targetNode, ...). Ensure this method strictly follows the rule: Any site where you have a spy/troop, OR any troop space adjacent to a site/troop you control. A common bug is forgetting that Spies grant presence at the site they are on, but Spies do not extend presence to adjacent nodes like Troops do.

    Total Control Calculation:

        Your MapNode tracks Occupant, but Tyrants has complex site scoring. "Control" = strict majority. "Total Control" = 100% occupancy + NO enemy spies.

        Ensure your MapManager updates the VictoryPoints for control markers dynamically whenever a PlaceSpy or Assassinate action occurs.

    Deck Cycling:

        Your Player.DrawCards method correctly reshuffles the discard pile when the deck is empty. This is standard, but ensure CleanUpTurn (which moves Hand/Played to Discard) happens strictly after all "End of Turn" effects (like promoting cards from hand).


__________________________________________

Architecture Upgrade: Event-Driven Design

The Problem: Currently, the MatchController calls TurnManager.EndTurn(), and that's it. If you add a UI later (to show a "YOUR TURN" banner) or an Audio system (to play a sound), you will have to tightly couple those systems to the TurnManager. The Standard: Use C# Events to let other systems "listen" for changes without TurnManager knowing they exist.

Update ITurnManager.cs & TurnManager.cs:
C#

// In ITurnManager
event EventHandler<Player> OnTurnChanged;

// In TurnManager
public event EventHandler<Player>? OnTurnChanged;

private void StartTurn()
{
    Player nextPlayer = Players[_currentPlayerIndex];
    CurrentTurnContext = new TurnContext(nextPlayer);

    // Notify listeners (UI, Audio, Animations)
    OnTurnChanged?.Invoke(this, nextPlayer);
}

Note: This allows you to write a separate UIManager that just subscribes to _turnManager.OnTurnChanged += ShowBanner;.

__________________________________________

Supplanting: You have HandleSupplant in ActionSystem.cs. In the rules, Supplanting is powerful because it returns the enemy troop and deploys yours.
Your code calls Assassinate then seems to rely on the player to Deploy, or intends to chain them. We'll need to double-check that flow to ensure it's atomic (happens in one action).

__________________________________________

################################################################################################################################################################################################################################################
################################################################################################################################################################################################################################################
################################################################################################################################################################################################################################################


LATER STAGES:
-UI Feedback (glowing and visual effect - red for not able, green - good to go, etc...)
-Functional tests for MonoGame visual parts
-BenchmarkDotNet if you want to scientifically prove the memory savings
-Security proof
-Server architecture


################################################################################################################################################################################################################################################
################################################################################################################################################################################################################################################
################################################################################################################################################################################################################################################


known bugs:
- you can return/assassinate/supplant without ever first deploying a troop (does not check presence correctly or is it a bug)? maybe fix it once we implement the starting sites?
  (but currently not so important until i implement starting sites where you will have to place your starting troop/s)